// Package core provides the main template engine and built-in tag functions for Wispy Core.
//
// The template engine supports:
//   - Per-render context (map[string]interface{} or custom structs)
//   - Custom tag functions (block and inline)
//   - Dot notation for nested map lookups (e.g., {%user.name%})
//   - Block tags (e.g., if, for, unless, case, set, comment)
//
// Built-in tag functions:
//   - IfTemplate: Conditional rendering ({%if condition%}...{%endif%})
//   - ForTemplate: Looping over slices/arrays ({%for item in items%}...{%endfor%})
//   - AssignTemplate: Assign a value to a variable in the context ({%assign var value%})
//   - CommentTemplate: Ignore content ({%comment%}...{%endcomment%})
//   - CaseTemplate: Switch/case logic ({%case var%}...{%when value%}...{%endcase%})
//   - UnlessTemplate: Render if condition is false ({%unless condition%}...{%endunless%})
//   - DefineTemplate: Define a named block ({%define "name"%}...{%enddefine%})
//   - RenderTemplate: Render a previously defined block ({%render "name"%})
//   - SanitizeTemplate: Escape HTML special characters for safe output ({%sanitize var%})

var IfTemplate = models.TemplateTag{
	Name: "if",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		var errs []error
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 2 {
			errs = append(errs, fmt.Errorf("missing condition in if tag"))
			return pos, errs
		}
		cond := parts[1]
		endTag := common.WrapBraces("endif")
		endIdx := strings.Index(raw[pos:], endTag)
		if endIdx == -1 {
			errs = append(errs, fmt.Errorf("could not find end tag for if"))
			return pos, errs
		}
		content := raw[pos : pos+endIdx]
		m, _ := ctx.Data.(map[string]interface{})
		if m != nil && IsTruthy(m[cond]) {
			sb.WriteString(content)
		}
		return pos + endIdx + len(endTag), errs
	},
}

var ForTemplate = models.TemplateTag{
	Name: "for",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		var errs []error
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 4 || parts[2] != "in" {
			errs = append(errs, fmt.Errorf("invalid for tag syntax"))
			return pos, errs
		}
		varName := parts[1]

		// Extract list name and check for filters
		remainingParts := strings.Join(parts[3:], " ")
		listNameWithFilters := strings.TrimSpace(remainingParts)
		listName, filters := ParseFilterChain(listNameWithFilters)

		// Check for literal string values with quotes
		var directValue interface{}
		if len(listName) >= 2 && (listName[0] == '"' && listName[len(listName)-1] == '"' || listName[0] == '\'' && listName[len(listName)-1] == '\'') {
			directValue = listName[1 : len(listName)-1]
		}

		// Use only the engine's delimiters for end tag detection
		endTag := ctx.Engine.StartDelim + "endfor" + ctx.Engine.EndDelim
		endIdx := strings.Index(raw[pos:], endTag)
		if endIdx == -1 {
			errs = append(errs, fmt.Errorf("could not find end tag for for"))
			return pos, errs
		}
		content := raw[pos : pos+endIdx]

		// Get the list to iterate over
		var list interface{}
		if directValue != nil {
			list = directValue
		} else {
			m, _ := ctx.Data.(map[string]interface{})
			if m != nil {
				list = ResolveDotNotation(m, listName)
			}
		}

		// Apply filters if present
		if len(filters) > 0 && ctx.Engine != nil {
			list = ApplyFilters(list, filters, ctx.Engine.FilterMap)
		}

		m, _ := ctx.Data.(map[string]interface{})
		if list != nil {
			engine := NewTemplateEngine(ctx.Engine.FuncMap)
			switch v := list.(type) {
			case string:
				localCtx := make(map[string]interface{})
				for k, val := range m {
					localCtx[k] = val
				}
				localCtx[varName] = v
				newCtx := NewTemplateContext(localCtx, ctx.Engine, ctx.InternalContext)
				res, _ := Render(content, engine, newCtx)
				sb.WriteString(res)
			case []string:
				for _, item := range v {
					localCtx := make(map[string]interface{})
					for k, val := range m {
						localCtx[k] = val
					}
					localCtx[varName] = item
					newCtx := NewTemplateContext(localCtx, ctx.Engine, ctx.InternalContext)
					res, _ := Render(content, engine, newCtx)
					sb.WriteString(res)
				}
			case []interface{}:
				for _, item := range v {
					localCtx := make(map[string]interface{})
					for k, val := range m {
						localCtx[k] = val
					}
					localCtx[varName] = item
					newCtx := NewTemplateContext(localCtx, ctx.Engine, ctx.InternalContext)
					res, _ := Render(content, engine, newCtx)
					sb.WriteString(res)
				}
			}
		}
		return pos + endIdx + len(endTag), errs
	},
}

// AssignTemplate assigns a value to a variable in the context for the rest of the render.
var AssignTemplate = models.TemplateTag{
	Name: "assign",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		errs := []error{}
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 3 {
			errs = append(errs, fmt.Errorf("assign tag requires variable name and value"))
			return pos, errs
		}
		varName := parts[1]
		value := strings.Join(parts[2:], " ")

		// Ensure we're writing to a map that will be used in future renders
		if m, ok := ctx.Data.(map[string]interface{}); ok {
			m[varName] = value
		}

		return pos, errs
	},
}

// CommentTemplate ignores all content between comment and endcomment.
var CommentTemplate = models.TemplateTag{
	Name: "comment",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		endTag := "{%endcomment%}"
		endIdx := strings.Index(raw[pos:], endTag)
		if endIdx == -1 {
			return pos, []error{fmt.Errorf("could not find end tag for comment")}
		}
		return pos + endIdx + len(endTag), nil
	},
}

// UnlessTemplate renders content only if the condition is false.
var UnlessTemplate = models.TemplateTag{
	Name: "unless",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		errs := []error{}
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 2 {
			errs = append(errs, fmt.Errorf("missing condition in unless tag"))
			return pos, errs
		}
		cond := parts[1]
		endTag := "{%endunless%}"
		endIdx := strings.Index(raw[pos:], endTag)
		if endIdx == -1 {
			errs = append(errs, fmt.Errorf("could not find end tag for unless"))
			return pos, errs
		}
		content := raw[pos : pos+endIdx]
		m, _ := ctx.Data.(map[string]interface{})
		if m != nil && !IsTruthy(m[cond]) {
			sb.WriteString(content)
		}
		return pos + endIdx + len(endTag), errs
	},
}

// CaseTemplate implements a simple switch/case logic.
var CaseTemplate = models.TemplateTag{
	Name: "case",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		errs := []error{}
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 2 {
			errs = append(errs, fmt.Errorf("missing variable in case tag"))
			return pos, errs
		}
		varName := parts[1]
		endTag := "{%endcase%}"
		whenTag := "{%when "
		endIdx := strings.Index(raw[pos:], endTag)
		if endIdx == -1 {
			errs = append(errs, fmt.Errorf("could not find end tag for case"))
			return pos, errs
		}

		// Get the case value
		m, _ := ctx.Data.(map[string]interface{})
		var val interface{}
		if m != nil {
			val = m[varName]
		}
		valStr := fmt.Sprint(val)

		// Parse and process the case block
		caseBlock := raw[pos : pos+endIdx]

		// Find and extract each when tag and its content
		position := 0

		for position < len(caseBlock) {
			whenStart := strings.Index(caseBlock[position:], whenTag)
			if whenStart == -1 {
				break // No more when tags
			}
			whenStart += position

			// Find the end of this when tag
			whenTagEnd := strings.Index(caseBlock[whenStart:], "%}")
			if whenTagEnd == -1 {
				break // Invalid format
			}
			whenTagEnd += whenStart

			// Get the when value
			whenValue := strings.TrimSpace(caseBlock[whenStart+len(whenTag) : whenTagEnd])

			// Find the next when tag or end of case
			nextWhenStart := strings.Index(caseBlock[whenTagEnd+2:], whenTag)
			var contentEnd int
			if nextWhenStart == -1 {
				contentEnd = len(caseBlock) // No more when tags
			} else {
				contentEnd = whenTagEnd + 2 + nextWhenStart // Content ends where next when starts
			}

			// If the value matches, add the content and stop processing
			if whenValue == valStr {
				sb.WriteString(caseBlock[whenTagEnd+2 : contentEnd])
				break
			}

			// Move to next when block
			if nextWhenStart == -1 {
				break // No more when tags
			}
			position = whenTagEnd + 2 + nextWhenStart
		}
		return pos + endIdx + len(endTag), errs
	},
}

// DefineTemplate allows defining a named block: {%define "name"%}...{%enddefine%}
var DefineTemplate = models.TemplateTag{
	Name: "define",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		errs := []error{}
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 2 {
			errs = append(errs, fmt.Errorf("define tag requires a block name"))
			return pos, errs
		}

		if ctx.Engine == nil {
			errs = append(errs, fmt.Errorf("define tag requires a template engine context"))
			return pos, errs
		}

		// Removed debug print statements

		name := strings.Trim(parts[1], "\"'")
		endTag := ctx.Engine.StartDelim + "enddefine" + ctx.Engine.EndDelim
		if !strings.Contains(raw[pos:], endTag) {
			errs = append(errs, fmt.Errorf("could not find end tag for define: %s", name))
			return pos, errs
		}
		endIdx := strings.Index(raw[pos:], endTag)
		content := raw[pos : pos+endIdx]
		// Store block in InternalContext (as map[string]string)
		var blockMap map[string]string
		if ctx.InternalContext == nil {
			blockMap = map[string]string{}
			ctx.InternalContext = blockMap
		} else if bm, ok := ctx.InternalContext.(map[string]string); ok {
			blockMap = bm
		} else {
			blockMap = map[string]string{}
			ctx.InternalContext = blockMap
		}
		blockMap[name] = content
		return pos + endIdx + len(endTag), errs
	},
}

// RenderTemplate renders a previously defined block: {%render "name"%}
var RenderTemplate = models.TemplateTag{
	Name: "render",
	Render: func(ctx TemplateCtx, sb *strings.Builder, tagContents, raw string, pos int) (int, []error) {
		errs := []error{}
		parts := common.FieldsRespectQuotes(tagContents)
		if len(parts) < 2 {
			errs = append(errs, fmt.Errorf("render tag requires a block name"))
			return pos, errs
		}
		name := strings.Trim(parts[1], "\"'")
		var blockMap map[string]string
		if ctx.InternalContext == nil {
			errs = append(errs, fmt.Errorf("no blocks defined for render: %s (InternalContext is nil)", name))
			return pos, errs
		}
		if bm, ok := ctx.InternalContext.(map[string]string); ok {
			blockMap = bm
		} else {
			errs = append(errs, fmt.Errorf("InternalContext is not a map[string]string for render: %s", name))
			return pos, errs
		}
		if blockMap == nil {
			errs = append(errs, fmt.Errorf("no blocks defined for render: %s (blockMap is nil)", name))
			return pos, errs
		}
		block, ok := blockMap[name]
		if !ok {
			errs = append(errs, fmt.Errorf("block not found for render: %s", name))
			return pos, errs
		}
		// Render the block content with the current context
		engine := NewTemplateEngine(ctx.Engine.FuncMap)
		res, _ := Render(block, engine, ctx)
		sb.WriteString(res)
		return pos, errs
	},
}